name: Nightly Shopify → CSV

on:
  schedule:
    # 3:00 UTC daily
    - cron: "0 3 * * *"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  sweep:
    runs-on: ubuntu-latest
    env:
      SHOP: ${{ secrets.SHOPIFY_SHOP }}
      TOKEN: ${{ secrets.SHOPIFY_ADMIN_TOKEN }}
      NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build products.csv from Shopify
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const SHOP = process.env.SHOP;
          const TOKEN = process.env.TOKEN;

          if (!SHOP || !TOKEN) {
            console.error("Missing SHOPIFY_SHOP or SHOPIFY_ADMIN_TOKEN.");
            process.exit(1);
          }

          // ---- read base codes from repo (first column = code) ----
          const baseCsvPath = path.join(process.cwd(), "public", "data", "base_products.csv");
          const baseCodes = [];
          try {
            const txt = fs.readFileSync(baseCsvPath, "utf8");
            const lines = txt.split(/\r?\n/).filter(Boolean);
            lines.shift(); // header
            for (const line of lines) {
              const code = (line.split(",")[0] || "").trim();
              if (code) baseCodes.push(code);
            }
          } catch (e) {
            console.error("Could not read base_products.csv:", e.message);
            process.exit(1);
          }

          // Map tag -> base code. Accept full code OR alias (model-only).
          // Examples mapped to same base:
          //   CC1717 <-> 1717
          //   BC3413 <-> 3413
          //   AS5001T <-> 5001T
          //   SS_SATU001 <-> SATU001
          //   CHM2580 <-> M2580, CHOW1086 <-> OW1086, CHMC1086 <-> MC1086, CHMC1087 <-> MC1087
          const aliasToBase = new Map();
          for (const code of baseCodes) {
            const U = code.toUpperCase();
            aliasToBase.set(U, code); // full code

            // after last underscore (SS_SATU001 -> SATU001)
            const afterUnderscore = U.split("_").pop();
            if (afterUnderscore && afterUnderscore !== U) aliasToBase.set(afterUnderscore, code);

            // strip a 2-letter brand prefix (e.g., CHM2580 -> M2580)
            const stripBrand = U.replace(/^[A-Z]{2}_?/, "");
            if (stripBrand && stripBrand !== U) aliasToBase.set(stripBrand, code);
          }

          // ---- fetch all products (REST) ----
          const apiVersion = "2023-10"; // stable
          async function fetchAllProducts() {
            let url = `https://${SHOP}/admin/api/${apiVersion}/products.json?limit=250&status=active`;
            const out = [];
            while (url) {
              const res = await fetch(url, {
                headers: {
                  "X-Shopify-Access-Token": TOKEN,
                  "Content-Type": "application/json",
                },
              });
              if (!res.ok) {
                const body = await res.text();
                throw new Error(`Shopify ${res.status}: ${body}`);
              }
              const data = await res.json();
              out.push(...(data.products || []));
              const link = res.headers.get("link") || res.headers.get("Link");
              if (link && /rel="next"/.test(link)) {
                const m = link.match(/<([^>]+)>;\s*rel="next"/);
                url = m ? m[1] : null;
              } else {
                url = null;
              }
            }
            return out;
          }

          function normalizeTagSet(tags) {
            return new Set((tags || "").split(",").map(t => t.trim().toUpperCase()).filter(Boolean));
          }

          function variantColorSize(product, variant) {
            const names = (product.options || []).map(o => (o.name || "").toLowerCase());
            const vals = [variant.option1, variant.option2, variant.option3];
            let color = "", size = "";
            for (let i = 0; i < names.length; i++) {
              const n = names[i];
              const v = (vals[i] || "").toString();
              if (!n) continue;
              if (!color && (n.includes("color") || n.includes("colour"))) color = v;
              if (!size && n.includes("size")) size = v;
            }
            if (!color) color = (vals[0] || "").toString();
            if (!size) size = (vals[1] || "").toString();
            return { color, size };
          }

          function variantImage(product, variant) {
            if (variant.image_id) {
              const img = (product.images || []).find(i => i.id === variant.image_id);
              if (img?.src) return img.src;
            }
            return product?.image?.src || "";
          }

          (async () => {
            const products = await fetchAllProducts();

            const rows = [];
            rows.push(["sku","base_code","title","color","size","image_src","enabled"]);

            for (const p of products) {
              const tagSet = normalizeTagSet(p.tags);

              // find a tag that matches either the full base code OR a model-only alias
              let baseCode = "";
              for (const t of tagSet) {
                const hit = aliasToBase.get(t);
                if (hit) { baseCode = hit; break; }
              }
              if (!baseCode) continue; // no base -> skip

              for (const v of (p.variants || [])) {
                const sku = (v.sku || `${p.handle}-${v.id}`).toString();
                const { color, size } = variantColorSize(p, v);
                const img = variantImage(p, v);
                const enabled = p.status === "active" ? "true" : "false";
                const title = `${p.title} — ${v.title || [color, size].filter(Boolean).join(" ")}`.trim();
                rows.push([sku, baseCode, title, color, size, img, enabled]);
              }
            }

            const outDir = path.join(process.cwd(), "public", "data");
            fs.mkdirSync(outDir, { recursive: true });
            const csv = rows.map(r => r.map(s => String(s ?? "").replace(/"/g,'""'))
                                     .map(s => /[",\n]/.test(s) ? `"${s}"` : s).join(",")).join("\n");
            fs.writeFileSync(path.join(outDir, "products.csv"), csv, "utf8");
            fs.writeFileSync(path.join(outDir, "meta.json"), JSON.stringify({ last_updated: new Date().toISOString() }), "utf8");
            console.log("Wrote products.csv and meta.json");
          })().catch(e => {
            console.error(e);
            process.exit(1);
          });
          NODE

      - name: Commit data files if changed
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [[ -n $(git status --porcelain public/data) ]]; then
            git add public/data/products.csv public/data/meta.json
            git commit -m "chore(data): nightly Shopify sweep → products.csv"
            git push
          else
            echo "No changes in public/data"
          fi

      - name: Trigger Netlify build (optional)
        if: ${{ env.NETLIFY_BUILD_HOOK != '' }}
        run: |
          curl -sS -X POST "$NETLIFY_BUILD_HOOK" || true
